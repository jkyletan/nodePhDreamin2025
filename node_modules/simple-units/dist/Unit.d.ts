import { inspect } from "util";
import Group from "./Group.js";
export type Converter = (val: number) => number;
export type UnitFormat = {
    short: string[];
    long: {
        sg: string[];
        pl: string[];
    };
};
/**
 * Represents a standard measure that is used to express amounts.
 *
 * A unit is always part of one single {@link Group} (attribute: {@link Unit.group}).
 * It is always defined in relation to the base unit of its group.
 *
 * The exact relation is defined in the converter functions {@link Unit.fromBase} and {@link Unit.toBase}.
 * Thereby `fromBase(val: number) => number` defines the conversion from the base unit to `this` and `toBase(val: number) => number` vice versa.
 * As a result of this simple concept, all units of a group are convertible into each other.
 *
 * The 4th important property of each unit is its {@link Unit.format}.
 * This defines the unit's shape. It allows firstly the parser to recognize the unit in a string and
 * secondly it provides the basis for the `.format()` method of the {@link Convertible}.
 *
 * Lastly every unit is part of a unit system (attribute: {@link Unit.system}).
 * This meta information is used for the {@link Convertible}'s `.asBest()` method.
 * By default, the Convertible always remains in the same system of units.
 */
export default class Unit {
    /**
     * The unit's {@link Group}. Units belonging to the same group are convertible into each other.
     */
    get group(): Group;
    /**
     * The unit's {@link UnitFormat}. Holds the unit's unique symbols,
     * which allow the parser to recognize the unit in a string.
     * Added to that it provides the basis for the `.format()` method of the {@link Convertible}.
     */
    readonly format: UnitFormat;
    /**
     * The unit system the unit is belonging to. E.g. `imperial`, `metric`, ...
     *
     * This meta information is used for the {@link Convertible}'s `.asBest()` method.
     * By default, the Convertible always remains in the same system of units.
     */
    readonly system: string;
    /**
     * Converts a value from this unit to the group's base unit.
     * @param val value in this unit
     * @returns value in the group's base unit
     */
    readonly toBase: Converter;
    /**
     * Converts a value from the group's base unit to this unit.
     * @param val value in the group's base unit
     * @returns value in this unit
     */
    readonly fromBase: Converter;
    /**
     * @hidden
     */
    readonly _internal: {
        _group: Group | null;
    };
    /**
     * Creates a standard measure that is used to express amounts.
     * @param format the unit's format, holds the unit's different symbols (e.g. `m, metre, meters` for the unit meter)
     * @param var1 function to convert a value from this unit to the group's base unit
     * @param var2 function to convert a value from the group's base unit to this unit
     * @param system the unit system the unit is belonging to
     */
    constructor(format: UnitFormat, fromBase: Converter, toBase: Converter, system: string);
    /**
     * Creates a standard measure that is used to express amounts.
     *
     * Using this constructor function one doesn't need to specify functions describing how to convert the unit to the group's base unit and vice versa.
     *
     * Instead one only specifies the mathematical relation the the base unit - in the form of a ratio and a shift.
     *
     * **Example**: You want to define the unit <i>Fahrenheit</i> and you have already defined the base unit <i>Kelvin</i>.
     * You know the formula to convert a value from <i>Fahrenheit</i> to <i>Kelvin</i> is: `°F * 5/9 + (45967/180) = °K`.
     * Using the other constructor function you had to write the following:
     * ```
     * new Unit({...}, (val) => (val - (45967/180)) / 5/9, (val) => val * 5/9 + (45967/180), ...);
     * ```
     * As you see there is repetitive code. Couldn't one save one of the two converter functions?
     * Lets see how we create the unit using this constructor.
     * ```
     * new Unit({...}, 5/9, 45967/180, ...)
     * ```
     * `5/9` is the ratio between the units, `45967/180` the shift. Much easier, isn't it? And no repetitive code!
     */
    constructor(format: UnitFormat, ratio: number, shift: number, system: string);
    /**
     * Returns the unit's standard string representation - therefore the most common symbol. For example `'m'` is returned for the unit meter.
     * @returns the unit's standard string representation
     */
    toString(): string;
    /**
     * @hidden
     */
    [inspect.custom](depth: any, options: any): any;
    /**
     * Returns an array of units to which this unit can be converted.
     * @returns an array of units to which this unit can be converted
     */
    possibilities(): string[];
    /**
     * Creates a string array holding all this unit's different notations.
     * @returns a string array holding all this unit's different notations
     */
    computeNotations(): string[];
}
//# sourceMappingURL=Unit.d.ts.map