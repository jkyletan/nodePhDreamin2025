import { inspect } from "util";
import CollectionEditor from "./CollectionEditor.js";
import Convertible from "./Convertible.js";
import UnknownGroupError from "./errors/UnknownGroupError.js";
import UnknownUnitError from "./errors/UnknownUnitError.js";
/**
 * Represents a collection of units (see {@link Unit}) structured in groups (see {@link Group}).
 *
 * Offers key functionality like converting from one unit to another.
 * Is the center at which all of the library's features are brought together.
 *
 * The basic structure of any collection is basically following: A collection is the parent of
 * multiple groups. Groups are parents of multiple units.
 *
 * <b>Example</b>:
 * ```
 * Collection
 *  |
 *  |____Group "length"
 *  |      |___Unit "meter"
 *  |      |___Unit "inch"
 *  |      |___ (...)
 *  |____Group "mass"
 *  |      |___Unit "kilogram"
 *  |      |___Unit "pound"
 *  |      |___ (...)
 *  |____Group "custom"
 *  |      |___Unit "small coins"
 *  |      |___Unit "big coins"
 *
 * ```
 *
 * Collections are not static. In fact they are very flexible. You can add, overwrite and remove unit groups using the {@link Collection.Editor}.
 * Added to that groups are editable in the same way (see {@link Group.Editor}),
 * which leads to the fact that groups can be modified in their entirety at runtime.
 */
class Collection {
    /**
     * Creates a new collection.
     */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    constructor() {
        /**
         * All units of the collection arranged in a map. This map is used to improve performance.
         * @hidden
         */
        this.units = new Map();
        /**
         * All groups of the collection arranged in a map.
         */
        this._groups = new Map();
        /**
         * These methods are only used internally.
         * @hidden
         */
        this._internal = {
            /**
             * Adds a string-unit-association to the {@link units} map.
             * @param name the unit's string representation
             * @param unit the unit
             */
            _setUnit: (name, unit) => {
                this.units.set(name, unit);
            },
            /**
             * Removes a string-unit-association from the {@link units} map.
             * @param name the unit's string representation
             */
            _deleteUnit: (name) => {
                this.units.delete(name);
            },
            /**
             * Returns the collection's groups.
             * @returns
             */
            _groups: () => this._groups,
            _units: () => this.units,
        };
        /**
         * The collection's editor. Provides methods to add, remove and overwrite unit groups.
         *
         * @see CollectionEditor
         */
        this.Editor = new CollectionEditor(this);
    }
    /**
     * Returns a string array containing the names of all groups.
     * @returns a string array containing the names of all groups
     */
    groups() {
        return Array.from(this._groups.keys());
    }
    /**
     * Returns a string array containing the short names of all units.
     * @returns a string array containing the short names of all units
     */
    possibilities() {
        const units = [];
        const keys = [];
        this.units.forEach((unit, key) => {
            if (!units.includes(unit)) {
                units.push(unit);
                keys.push(key);
            }
        });
        return keys;
    }
    /**
     * Returns whether the passed unit is supported.
     * @param unit the unit
     * @returns whether the passed unit is supported
     */
    isSupported(unit) {
        return Boolean(this.units.get(unit));
    }
    /**
     * Returns the unit object belonging to the given unit.
     * @param unit the unit as string
     * @returns the unit object belonging to the given unit string
     * @see Unit
     */
    unit(unit) {
        const result = this.units.get(unit);
        if (!result)
            throw new UnknownUnitError(`Unknown unit '${unit}'!`);
        return result;
    }
    /**
     * Returns the group having the passed name.
     * @param group the group's name
     * @returns the group itself
     * @see Group
     */
    group(group) {
        const result = this._groups.get(group);
        if (!result)
            throw new UnknownGroupError(`Unknown unit '${group}'!`);
        return result;
    }
    /**
     * Returns a convertible having the given value and unit. Does exactly the same as {@link Collection.Convertible}.
     * @param value the convertible's value (e.g. `20`)
     * @param unit the convertible's unit (e.g. `°F`)
     * @returns a convertible having the given value and unit
     * @see Convertible
     */
    from(value, unit) {
        return new Convertible(value, this.unit(unit));
    }
    /**
     * Returns a convertible having the given value and unit. Alias to {@link Collection.from}.
     * @param value the convertible's value (e.g. `20`)
     * @param unit the convertible's unit (e.g. `°F`)
     * @returns a convertible having the given value and unit
     * @see Convertible
     */
    Convertible(value, unit) {
        return this.from(value, unit);
    }
    /**
     * Returns the collection as human-readable string.
     * @returns the collection as string
     */
    toString() {
        let result = "Collection [\n";
        this._groups.forEach((group, key) => {
            result += `  Group '${key}' [\n    `;
            const possibilities = group.possibilities();
            for (let i = 0; i < possibilities.length; i++) {
                result += possibilities[i];
                if (i + 1 === possibilities.length)
                    result += "\n";
                else if ((i + 1) % 12 === 0)
                    result += ",\n    ";
                else
                    result += ", ";
            }
            result += "  ],\n";
        });
        result += "]";
        return result;
    }
    /**
     * @hidden
     */
    [inspect.custom](depth, options) {
        let result = "Collection [\n";
        this._groups.forEach((group, key) => {
            result += `  Group `;
            result += options.stylize(`'${key}'`, "string");
            result += ` [\n    `;
            const possibilities = group.possibilities();
            for (let i = 0; i < possibilities.length; i++) {
                result += options.stylize(possibilities[i], "special");
                if (i + 1 === possibilities.length)
                    result += "\n";
                else if ((i + 1) % 12 === 0)
                    result += ",\n    ";
                else
                    result += ", ";
            }
            result += "  ],\n";
        });
        result += "]";
        return result;
    }
}
/**
 * @hidden
 */
Collection.None = new Collection();
export default Collection;
//# sourceMappingURL=Collection.js.map